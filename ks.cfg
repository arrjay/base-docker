#version=RHEL7
# System authorization information
auth --enableshadow --passalgo=sha512

# we're pretending to be a CDROM, even if we're...kinda not
cdrom

# Use text mode
text
# Dont' run the Setup Agent on first boot
firstboot --disable
# Keyboard layouts
keyboard --vckeymap=us --xlayouts='us'
# System language
lang en_US.UTF-8

# partitioning is done via %pre madness
%include /tmp/part-include

# configure root password
rootpw --iscrypted $6$ddmoPYtWupIPA/Vn$9EcJ170zv2lnVP6mLK0W9zAWaf7OYmu3yHk9dY0/pl5dPluvkTp/wTLmT4C7BAIE4FAGxPQ0K0zPwftvdvl5/0

# networking is also in %pre (well, unless it's in %post)
%include /tmp/net-include

# reboot when done
%include /tmp/reboot-flag

# System timezone
timezone America/Los_Angeles --isUtc

# System services
services --enabled="chronyd"

%packages
@core
@base
@virtualization-hypervisor
@virtualization-tools
grub2
grub2-efi
grub2-efi-modules
shim
efibootmgr
%include /tmp/package-include

# needed for org_fedora_oscap addon
openscap
openscap-scanner
scap-security-guide

%end

%addon org_fedora_oscap
    content-type = scap-security-guide
    profile = common
%end

%addon com_redhat_kdump --enable --reserve-mb='auto'

%end

%pre
# be a chatterbox here
set -x

# on with nullglub
shopt -s nullglob

# parts that can be _reset_ by system config but have a default
reboot_flag="reboot"
inst_fqdn="localhost.localdomain"

# first get if we have a syscfg on cmdline
read cmdline < /proc/cmdline
for ent in $cmdline ; do
  case $ent in
    syscfg=*)
      syscfg=${ent#syscfg=}
      ;;
  esac
done

# get whatever diskdev we're running on
repodisk=$(awk '$2 == "/run/install/repo" { print $1 }' < /proc/mounts)
repodisk=${repodisk%1}

# well... let's try to find one
if [ -z "${syscfg}" ] ; then
  # first, chassis serial number?
  if [ -f /sys/class/dmi/id/chassis_serial ] ; then
    read cha_ser < /sys/class/dmi/id/chassis_serial
    case $cha_ser in
      "To Be Filled By O.E.M.")
      # yuck, go grab ethernet MACs by PCI topology
      for macfile in /sys/devices/pci*/*/net/*/address /sys/devices/pci*/*/*/net/*/address ; do
        read mac < "${macfile}"
        case $mac in
          "80:ee:73:1c:1e:ac")
            syscfg=hafnium
            break
            ;;
        esac
      done
      ;;
    esac
  fi
fi

# always stop lvm
vgchange -an

# always stop md devices
for md in /dev/md[0-9]* ; do
  mdadm -S "${md}"
done

# always erase disks, write a new gpt
for d in /dev/sd*[^0-9] ; do
  # skip where we booted
  if [ "${d}" == "${repodisk}" ] ; then continue ; fi

  # partitions...
  for part in ${d}[0-9]* ; do
    wipefs -a "${part}"
  done

  # label
  wipefs -a "${d}"
done

# this holds any needed conditional package statements
touch /tmp/package-include

# system specific configuration
if [ "${syscfg}" == "hafnium" ] ; then
  reboot_flag="poweroff"

  # hafnium disk setup
  biosboot_dev=''
  efi_sp_dev=''
  boot_dev=''
  sys_dev=''

  # partition drives
  for d in /dev/sd*[^0-9] ; do
    if [ "${d}" == "${repodisk}" ] ; then continue ; fi
    parted "${d}" mklabel gpt
    parted "${d}" mkpart biosboot 1m 5m
    parted "${d}" toggle 1 bios_grub
    parted "${d}" toggle 1 legacy_boot
    biosboot_dev="${biosboot_dev} ${d}1"

    parted "${d}" mkpart '"EFI System Partition"' 5m 300m
    parted "${d}" toggle 2 boot
    efi_sp_dev="${efi_sp_dev} ${d}2"

    parted "${d}" mkpart boot 300m 800m
    parted "${d}" toggle 3 raid
    boot_dev="${boot_dev} ${d}3"

    parted "${d}" mkpart primart 800m 100%
    parted "${d}" toggle 4 raid
    sys_dev="${sys_dev} ${d}4"
  done

  # start arrays and wipe any filesystems we suddenly get ;)
  efi_sp_arr=( ${efi_sp_dev} )
  boot_arr=( ${boot_dev} )
  sys_arr=( ${sys_dev} )
  mdadm --create /dev/md/efi -Nefi -l1 --homehost=${syscfg} -n ${#efi_sp_arr[@]} --metadata=1.0 ${efi_sp_dev}
  wipefs -a /dev/md/efi
  mdadm --create /dev/md/boot -Nboot -l1 --homehost=${syscfg} -n ${#boot_arr[@]} --metadata=1.0 ${boot_dev}
  wipefs -a /dev/md/boot
  mdadm --create /dev/md/system -Nsystem -l1 --homehost=${syscfg} -n ${#sys_arr[@]} --metadata=1.1 ${sys_dev}
  wipefs -a /dev/md/system

  # format the ESP
  mkfs.vfat -F32 /dev/md/efi

  # tell kickstart we already have raid volumes, and build lvm from there.
  {
    # partitions
    for part in ${biosboot_dev} ; do
      p=$(basename "${part}")
      printf 'part biosboot --fstype=biosboot --onpart=%s\n' "${p}"
    done
    for part in ${efi_sp_dev} ; do
      p=$(basename "${part}")
      i=${p:2:1}
      printf 'part raid.0%s --fstype="mdmember" --noformat --onpart=%s\n' "${i}" "${p}"
    done
    for part in ${boot_dev} ; do
      p=$(basename "${part}")
      i=${p:2:1}
      printf 'part raid.1%s --fstype="mdmember" --noformat --onpart=%s\n' "${i}" "${p}"
    done
    for part in ${sys_dev} ; do
      p=$(basename "${part}")
      i=${p:2:1}
      printf 'part raid.2%s --fstype="mdmember" --noformat --onpart=%s\n' "${i}" "${p}"
    done

    # RAIDs
    printf 'raid pv.0 --device=system --fstype="lvmpv" --level=1 --useexisting\n'
    printf 'raid /boot --device=boot --fstype="ext2" --useexisting --label="/boot"\n'
    printf 'raid /boot/efi --device=efi --fstype="efi" --fsoptions="umask=0077,shortname=winnt" --noformat --useexisting --label="EFISP"\n'

    # LVM
    printf 'volgroup hafnium pv.0\n'
    printf 'logvol / --vgname=hafnium --fstype=ext4 --name=root --size=18432\n'
    printf 'logvol swap --vgname=hafnium --name=swap --size=512\n'

    # LVM thinpool
    printf 'logvol none --vgname=hafnium --thinpool --name=thinpool --size=18432 --grow\n'
    printf 'logvol /var/lib/libvirt/images --vgname=hafnium --thin --poolname=thinpool --fsoptions="defaults,discard" --fstype=ext4 --name=libvirt-images --size=18432\n'

    # tell kickstart to simply install the bootloader on the first drive - the biosboot handler actually DTRT
    printf 'bootloader --append=" crashkernel auto" --location=mbr --boot-drive=sda\n'
  } > /tmp/part-include

  # network setup
  # install systemd-networkd for post fun
  printf 'systemd-networkd\n' >> /tmp/package-include

  # set the hostname
  inst_fqdn="hafnium.bbxn.us"
fi

# hang the hostname up
printf 'network --hostname="%s"\n' "${inst_fqdn}" >> /tmp/net-include

# we always create reboot-flag
printf '%s\n' "${reboot_flag}" > /tmp/reboot-flag

# we always create post-vars.
touch /tmp/post-vars

# write out the syscfg for %post
if [ ! -z "${syscfg}" ] ; then
  printf 'syscfg="%s"\n' "${syscfg}" >> /tmp/post-vars
fi

%end

%post --nochroot --log=/mnt/sysimage/root/post.log
# be a chatterbox here
set -x

# on with nullglub
shopt -s nullglob

# pick up env vars from %pre
. /tmp/post-vars

# this particular vlan table is global since all HVs use it.
vlan[4]=netmgmt
vlan[5]=standard
vlan[7]=guest
vlan[66]=transit
vlan[70]=restricted
vlan[100]=virthost
vlan[303]=dmz
vlan[606]=chaos
vlan[999]=iot
vlan[2000]=pln
vlan[2002]=wext

# system specific configuration
if [ "${syscfg}" == "hafnium" ] ; then
  # configure the network using systemd-networkd here.
  mkdir -p /mnt/sysimage/etc/systemd/network/

  # shoot NetworkManager in the face
  ln -s /dev/null /mnt/sysimage/etc/systemd/system/NetworkManager.service
  ln -s /dev/null /mnt/sysimage/etc/systemd/system/NetworkManager-wait-online.service
  rm -f /mnt/sysimage/etc/systemd/system/dbus-org.freedesktop.NetworkManager.service.
  rm -f /mnt/sysimage/etc/systemd/system/multi-user.target.wants/NetworkManager.service.
  rm -f /mnt/sysimage/etc/systemd/system/dbus-org.freedesktop.nm-dispatcher.service.

  # disable ipv6 for most things
  printf 'net.ipv6.conf.default.disable_ipv6 = 1\nnet.ipv6.conf.lo.disable_ipv6 = 0\n' > /mnt/sysimage/etc/sysctl.d/40-ipv6.conf

  # enp2s0f0 is the top of the add-in card here
  topcard='enp2s0f0'
  printf '[Match]\nName=%s\n[Network]\nLinkLocalAddressing=no\nLLMNR=false\nIPv6AcceptRA=no\n' "${topcard}" > "/mnt/sysimage/etc/systemd/network/${topcard}.network"

  # create bridges,vlans
  for vid in "${!vlan[@]}" ; do
    printf '[NetDev]\nName=%s\nKind=bridge\n' "${vlan[$vid]}" > "/mnt/sysimage/etc/systemd/network/${vlan[$vid]}.netdev"
    printf '[Match]\nName=%s\n[Network]\nLinkLocalAddressing=no\nLLMNR=false\nIPv6AcceptRA=no\n' "${vlan[$vid]}" > "/mnt/sysimage/etc/systemd/network/${vlan[$vid]}.network"
    printf '[NetDev]\nName=vlan-%s\nKind=vlan\n[VLAN]\nId=%s\n' "${vlan[$vid]}" "${vid}" > "/mnt/sysimage/etc/systemd/network/vlan-${vlan[$vid]}.netdev"
    printf '[Match]\nName=vlan-%s\n[Network]\nBridge=%s\nLinkLocalAddressing=no\nLLMNR=false\nIPv6AcceptRA=no\n' "${vlan[$vid]}" "${vlan[$vid]}" > "/mnt/sysimage/etc/systemd/network/vlan-${vlan[$vid]}.network"
    # associate vlans to topdev
    printf 'VLAN=vlan-%s\n' "${vlan[$vid]}" >> "/mnt/sysimage/etc/systemd/network/${topcard}.network"
  done
fi

%end
